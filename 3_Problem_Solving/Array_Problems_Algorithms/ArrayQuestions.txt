===============================================================================================
1) Find peak element not smaller than its neighbours
===============================================================================================
Given an arr of n elements, that is first strictly increasing and then maybe strictly decreasing, find peak element in array.

eg:
    input: {10, 20, 15, 2, 23, 90, 67}
    Output: 20 or 90
    - 20 has neighbours less than itself, 90 also similar

    Edge case:
        - if strictly increasing, last element is peak
        - if strictly decreasing, first element is peak
        - if all value same, all values are peak

    Logic:
        - if first element > second element, return first element (strictly decreasing case)
        - if last element > 2nd last element, return last element (strictly increasing)
        - loop from 2nd idx (1 to N - 1), check i with i-1 & i+1 idx. return if i value larger than both


===============================================================================================
2) Find min / max element of array
===============================================================================================
Given an arr, write a function to find the minimum and maximum element in it

    Logic:
        - if arr.length == 1, min = max = element
        - init 2 var min = Integer.MAX_VALUE, max = Integer.MIN_VALUE
        - iterate through array, if arr[i] > max, max = arr[i] & arr[i] < min, min = arr[i]

===============================================================================================
Concatenation of Array
===============================================================================================
    - can use modulo operation to concatenate 2 arrays

    Input: nums = [1,2,1]
    Output: [1,2,1,1,2,1]

    Idea:
        - use modulo to keep smaller array index within range
        eg:
            - nums array size is 3
            - output array size is 6
            for (int i = 0; i < output.length; i++) {
                output[i] = nums[i % nums.length];
            }

===============================================================================================
Shuffle the array - 1
===============================================================================================
Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn]
Return the array in the form [x1,y1,x2,y2,...,xn,yn]

eg
Input: nums = [2,5,1,3,4,7], n = 3
Output: [2,3,5,4,1,7] 

Learnings:
    - create new array & use 2 pointers to traverse array
    - write down output idx to observe pattern, eg idx 0 1 2 3 4 5 -> 0 3 1 4 2 5

class Solution {
    public int[] shuffle(int[] nums, int n) {
        int[] newArr = new int[nums.length];
        int const_n = n;

        for (int i = 0; i < nums.length; i++) {
            if (i % 2 == 0) {
                newArr[i] = nums[n - const_n];
                n++;
            } else {
                newArr[i] = nums[n - 1]; // -1 to offset n++ from even side
            }
        }
        return newArr;
    }
}

===============================================================================================
Print all subset in an array
===============================================================================================
    - Number of subsets = 2^n (for size n array)
        - including the empty subset {}

